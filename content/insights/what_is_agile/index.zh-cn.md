---
title: '什么是敏捷？'
authors:
  - "wu_hong"
---

## 1. 成事

成事是人实现自身价值的方式，是人的本能。

无论采用什么样的哲学和方法论，我们都希望能成事，所以让我们先忘记敏捷，从第一性原理出发，想想什么是能成事。

### 1.1. 我们总是希望事情能做成

这是最基本的诉求，事情捡重要的做，评价事情成败的关键就是，这个事情中最重要的部分有没有做成，这个最重要的部分就是**范围**。

### 1.2. 我们希望做的事情能带来价值

不能带来**价值**的事情没有必要做，我们要做的事可能是生产产品，提供服务，设计解决方案。

以产品为例：

```
产品价值 = 用户价值 + 商业价值 + 社会价值
```

- 用户价值就是帮需求侧用户解决什么问题，再直白点就是帮客户赚了/省了多少钱。
- 商业价值就是作为产品供应侧，你从这笔交易中的获利，比较常见的如用户量、生产资料、财务收入、客户满意度等。
- 社会价值就是产品、服务或解决方案对社会的影响和贡献，比如可持续发展、环境保护、社会责任等。

### 1.3. 我们不仅希望把事做成，还希望把事情做漂亮

- 我们希望花费尽可能少**时间**和**成本**，把事情做成
    有限的时间，成本是做事不得不遵循的限制。
- 我们希望事情做的**质量**高

上面所提到的种种诉求互相制约，就形成了一个三角：

- 质量
- 价值
- 约束
    - 时间
    - 范围
    - 成本


## 2. 从人类历史中找到成事的最佳实践

### 2.1. 如何确保“事情能做成”？

- 设定计划
- 验收

### 2.2. 如何确保“做的事情能带来价值”？

- 排优先级
- 快速反馈


### 2.3. 如何确保“能把事情做漂亮”

- 如何“花费尽可能少**时间**和**成本**，把事情做成”
    - 排优先级

- 如何确保”事情做的**质量**高“
    - 验收

所以总结一下：

- 设定计划
- 排优先级
    - 帕累托法则，80/20法则(The 80/20 Rule)
- 快速反馈
    - Time Boxing
    - 增量交付
    - 响应变化
- 验收
    - 效率
    - 质量
        - ​一次只做一件事（Single-Tasking）

如果你是一个人在做事，没有团队，那么读到这里就够了，你只要把要做的事情分解为待办事项的列表，然后按照Time Boxing的方式，每隔一段时间把做好的一部分发放到市场上收集反馈，然后改进就可以了。

但是如果你是在靠团队做事，那么就得想想从个体到团队需要额外考虑哪些因素：

- 同步信息
    > 个体只有一个大脑，但是团队有多个大脑，那么就涉及到同步信息。
- 协作效率
    > - 个体是单兵作战，从头到尾只有自己，团队则不同，并行工作是常态，因此要考虑如何协作。
    > - 构建互信
- 稳定的生产力

因此我们得到一个团队的成事哲学：

- 设定计划
- 排优先级
- 快速反馈
- 验收
- 同步信息
- 协作效率
- 稳定的生产力

把以上成事哲学稍微整理一下就是敏捷。

## 3. 敏捷

敏捷这个术语是2001 年在[敏捷宣言](https://agilemanifesto.org/iso/zhchs/manifesto.html)中提出的。

2001年初，在美国犹他州雪鸟度假村，17个软件从业者聚在一起，组成了敏捷联盟，讨论研究了一遍从软件行业诞生以来的所有轻量级开发方法，然后发布了敏捷宣言。

敏捷宣言包含两部分内容：4个价值观和12条原则。

敏捷就源自敏捷宣言。

### 3.1. 敏捷宣言中的4个价值观

敏捷只是成事哲学的进一步抽象。

- **个体和互动** 高于 **流程和工具**
- **工作的软件** 高于 **详尽的文档**
- **客户合作** 高于 **合同谈判**
- **响应变化** 高于 **遵循计划**


### 3.2. 敏捷宣言中的12条原则

12条原则其实是4个价值观的衍生，是敏捷联盟担心人们看不懂敏捷价值观而作出的补充解释。

1. 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。

1. 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。

1. 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。

1. 业务人员和开发人员必须相互合作，项目中的每一天都不例外。

1. 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。

1. 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。

1. 可工作的软件是进度的首要度量标准。

1. 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。

1. 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。

1. 以简洁为本，它是极力减少不必要工作量的艺术。

1. 最好的架构、需求和设计出自自组织团队。

1. 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

## 4. Scrum

敏捷价值过于抽象了，我们拿着成事哲学来看看，有哪些实践能让一个团队成事。

- 设定计划
    - Sprint backlog
    - Sprint planning meeting
- 排优先级
    - Product backlog
- 快速反馈
    - Sprint
- 验收
    - Sprint Review meeting
    - Potential shippable product increment(PSPI)
- 同步信息
    - Sprint Refinement meeting
- 协作效率
    - Standup
    - Sprint retro meeting
    - Value Stream Mapping
- 稳定的生产力
    - Lead Time
    - Circle Time
    - Velocity

### 4.1 高效会议

无论是什么样的会议，最佳实践的原则只有一个：高效地完成这个会议的目标，高效是指避免浪费与会人员的时间。

Sprint中会议有5个：

#### Sprint Planning，迭代计划会

- 确定下一个Sprint的目标（commitment）和计划（待办事项列表）。
- 输入：
- 输出：

#### Daily Scrum（每日站会）：

- 更新进展和找出阻碍因素
- 所有的细节讨论都应放在站会之后。

#### Sprint Review，迭代回顾会

- 展示和演示已完成的工作成果给利益相关者。
- 收集利益相关者的反馈和建议。
- 评估已完成工作与产品愿景的符合程度。
- 确定下一步的优先事项和调整产品待办列表。

#### Sprint Retrospective，迭代总结会

- 回顾和评估前一个迭代的工作过程。
- 识别工作中的问题、挑战和改进机会。
- 制定行动计划来增进团队的效率和质量。
- 促进团队的持续学习和改进。

#### Backlog Refinement，待办列表梳理会议

- 澄清需求、解答问题并明确工作细节。
- 估算工作量和确定优先级。

Refinement 这个词是加工、提炼的意思，在scrum里，其实就是对下阶段的需求做一个讨论、澄清、细化的一个活动，希望通过这个活动，使得团队能对后续阶段的需求能有一个common understanding，尽量避免团队因为对需求理解的不一致所导致的各类问题，并帮助团队在下个迭代开始的时候更快进入开发状态，它一般是发生在下个迭代开始前的一段时间里。中文一般叫做产品待办列表梳理会议（product backlog refinement）
其实refinement在之前还有一个名字，叫做grooming，但据说这个词的意思在英国会令人不太舒服，所以后来scrum联盟就改用了refinement这个词。
需要注意的是，refinement并不止在会议上发生，需求的梳理其实不仅仅只发生在每个迭代的refinement的会议上，它其实应该是贯彻发生在整个软件开发的全过程中。只是在refinement 会议上做了最大量的需求梳理的工作，然后从sprint的开始，花费在需求梳理上的时间会慢慢减少，花费在软件设计开发上的时间慢慢增加，到了sprint得后期就慢慢没有了需求方面的工作而只剩下开发上面的工作了。

整个refinement的过程也可以简单看成发散+收敛的过程：
- 发散的意思就是在对一个story做梳理的前期，我们需要针对目标story做发散思维的讨论，尽力考虑到各个方面的问题、假设、困难，防止专家思维的局限，这是个脑暴的过程。
    - 暂缓对别人观点的评论
    - 鼓励异想天开的想法
    - 可以借“题”发挥，别人的观点上继续延生
    - 专注在story上，不要离题
    - 图文并茂，鼓励使用可视化的方式
    - 做加法，点子越多越好（先不关注点子的质量）

    为了更好的引导这个脑暴的过程，我们常见的指导分析方法有
    - FURPS+：“FURPS+”更像一个checklist，它能提醒我们在发散的时候要从这些角度去思考，避免有大块的遗漏。
        - Functionality （功能性）
        - Usability （可用性）
        - Reliability （可靠性）
        - Performance （性能相关的）
        - Supportability （其它对内部研发支持，比如文档、为了可测性、可扩展性等）
        - “+” （其它更多可能的考虑）
            - 设计上的限制（比如系统以前的架构局限）
            - 实现上得限制（比如语言，人力资源，操作环境等）
            - 接口的需求（外部依赖的接口和服务）
            - 硬件的需求（物理硬件的限制）
    - SQA
        相对于上面的FURPS+的方法，SQA的方法在我遇到的实际中更加常用和易用。
        SQA就是通过大家一起回答目标story的"Questions"，"Scope"，"Assumptions"三个问题来澄清我们的需求。
        - Question：任何对这个需求不清楚的问题
        - Scope：team为了完成这个需求到底要做哪些事，不做哪些事情
        - Assumptions：为了做这些事的前提假设，可能是成立的，也可能是不成立的
        这里会有很多疑问和假设，PO需要在团队讨论的过程中随时解答团队的疑问和澄清假设，不能当场澄清的，团队和PO需要会后带回去，在下个迭代planning meeting前完成澄清。
- 在充分发散的基础上我们就要开始收，这样我们才能拿到refinement最终的结果，这就是收敛的过程。为了帮助收敛，我们常用的手段有：
    - 明确产出结果形式
    - 投票找到公认的重点
    - 时间盒
